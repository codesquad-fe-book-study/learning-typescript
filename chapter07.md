# 인터페이스

## 7.1 별칭 타입 vs. 인터페이스

"일반적으로 인터페이스에서 타입스크립트 검사기가 더 빨리 작동합니다"

인터페이스가 타입 별칭보다 왜 검사기가 더 빨리 동작하는지 찾아 봤으나, 구글에는 검색결과가 제대로 나오지 않았습니다. 그래서 지피티에게 물어보니..

> 일반적으로 인터페이스는 타입 별칭보다 타입 검사 속도가 더 빠릅니다. *이는 인터페이스가 컴파일 타임에 검사되는 반면 타입 별칭은 런타임에 계산되기 때문입니다.*  
> 타입 별칭은 타입을 정의하는 데 유용하며, 복잡한 타입을 간결하게 표현할 수 있습니다. 그러나 이러한 표현식은 런타임에 해석되므로 컴파일 타임에는 검사되지 않습니다. 따라서 타입 별칭을 사용할 때는 컴파일러가 복잡한 계산을 수행하지 않도록 주의해야 합니다.  
> 반면에 인터페이스는 컴파일 타임에 검사되므로 런타임에 계산을 수행할 필요가 없습니다. 이는 인터페이스가 대규모 프로젝트에서 타입 검사를 수행할 때 더 빠르게 작동하는 이유 중 하나입니다.  
> 그러나 타입 별칭은 인터페이스보다 더 유연하게 타입을 정의할 수 있으므로 상황에 따라 적절한 선택을 해야 합니다. 또한 최신 버전의 타입스크립트에서는 성능 개선이 이루어져 타입 별칭을 사용해도 성능상 큰 문제가 없을 수 있습니다.

## 7.2.5 인덱스 시그니처

- 인터페이스 객체에 임의의 키와 그 키에 특정 타입의 값을 선언

```js
interface WordCounts {
  [i: string]: number;
}

const counts: WordCounts = {};
counts.apple = 0;

counts.cherry = false; // Error
```

- **!주의: 이런 타입의 객체는 값이 number면 string 키가 아닌 그 어떤 키도 바인딩 할 수 없다.**
- **!주의: 인덱스 시그니처는 타입 안정성을 완벽하게 보장하지 않는다**

```js
interface DatesByName {
  [i: string]: Date;
}

const publishDate: DatesByName = {
  date: new Date()
}

publishDate.date;  // ok
publishDate.hello; // Error가 예상되지만, Type: (index) DatesByName[string]: Date
```

## 7.4.1 이름이 충돌되는 멤버

- 병합된 인터페이스는 타입이 다른 동일한 이름의 속성을 여러 번 선언할 수 없다.
- 속성이 이미 인터페이스에 선언되어 있다면 나중에 병합된 인터페이스에서도 동일한 타입을 사용해야 된다.
- !궁금한 점: "그러나 병합된 인터페이스는 동일한 이름과 다른 '시그니처'를 가진 메서드는 정의할 수 있다. 이렇게 하면 메서드에 대한 '함수 오버로드'가 발생한다."  
-> 속성 구문은 안되고 왜 시그니처를 가진 메서드는 정의할 수 있나요?

