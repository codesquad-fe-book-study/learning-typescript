# 7장. 인터페이스

- 인터페이스는 `객체 형태를 설명하는 또 다른 방법`
- types alias로 정의된 객체 타입과 유사하지만 차별점 존재
  - 더 읽기 쉬운 오류 메시지
  - 더 빠른 컴파일러 성능
  - 클래스와의 더 나은 상호 운용성

## Type alias VS Interface

두 가지 모두 세미콜론과 쉼표 둘 다 가능하다.

인터페이스의 특징

- 속성 증가를 위해 병합이 가능하다.
- 클래스가 선언된 구조의 타입을 확인하는데 사용 가능하다.
- 일반적으로 인터페이스에서 타입 검사기가 더 빨리 작동한다. 내부적으로 더 쉽게 캐시할 수 있는 명명된 타입을 선언하기 때문이다.
- 이름 없는 객체 리터럴의 별칭이 아닌 이름이 있는 하나의 객체로 간주되므로 오류 메시지를 좀더 쉽게 읽을 수 있다.

## 읽기 전용 속성(readonly)

- 인터페이스에 정의된 객체의 속성을 재할당하지 못하도록 차단할 때, readonly 키워드를 추가한다.
- readonly 연산자는 타입 시스템에만 존재하며 인터페이스에서만 사용할 수 있다. 단지, 개발 중에 그 속성이 수정되지 못하도록 보호한다.

## 메서드와 속성 함수

- 메서드 구문: `test(): void;`
- 속성 함수 구문: `test: () => void;`

> 메서드는 readonly 선언이 불가능, 속성 함수는 가능

## 호출 시그니처

함수 타입과 유사하지만, 콜론(:)이 아닌 화살표(=>)로 표시한다.

```ts
interface TestImpl {
  (input: string): number;
}

const test: TestImpl = (input: string) => input.length;
```

## 인덱스 시그니처

- 자바스크립트 객체 속성 조회는 암묵적으로 키를 문자열로 변환하기 때문에 인터페이스의 객체는 일반적으로 문자열 키를 사용한다.

```ts
interface Example {
  [i: string]: number;
}
```

- 인덱스 시그니처는 객체에 값을 할당할 때 편리하지만 `타입 안정성을 완벽하게 보장하지는 못한다.`
- 명명된 속성이 더 구체적인 타입을 제공하고, 다른 모든 속성은 인덱스 시그니처의 타입을 대체하는 것으로 혼합해서 사용할 수 있다.
- 일반적으로는 인덱스 시그니처의 원시 속성보다 더 구체적인 속성 타입 리터럴을 사용한다.

```ts
interface Dog {
  name: 'hodu'; // 더 구체적인 리터럴
  [i: string]: string;
}
```

## 인터페이스 확장

- 인터페이스가 다른 인터페이스의 모든 멤버를 복사해서 선언할 수 있는 확장된 인터페이스
- 확장할 인터페이스의 이름 뒤에 `extends` 키워드를 추가한다.

### 재정의된 속성

- 타입 검사기는 재정의된 속성이 기본 속성에 할당되어있도록 강요한다.
- 즉, 재정의한 속성은 이전 정의보다 더 좁은 범위여야 한다.

### 다중 인터페이스 확장

- 인터페이스는 여러 개의 인터페이스를 확장해서 선언할 수 있다.
- extends 키워드 뒤에 쉼표로 인터페이스 이름을 구분해 사용하면 된다.

## 인터페이스 병합

- 여러 개의 인터페이스가 동일한 이름으로 동일한 스코프에 선언된 경우, 선언된 모든 필드를 포함하는 더 큰 인터페이스가 된다.
- 인터페이스 병합을 자주 사용하지는 않는다.
- 인터페이스 병합은 외부 패키지 또는 Window와 같은 내장된 전역 인터페이스를 보강하는데 특히 유용하다.

### 이름이 충돌되는 멤버

- 속성이 이미 인터페이스에 선언되어 있다면 나중에 병합된 인터페이스에서도 동일한 동일한 타입을 사용해야 한다.
- 같은 이름의 속성이 타입이 서로 다르면 오류가 발생한다.
- 다만, 동일한 이름과 다른 시그니처를 가진 메서드는 정의할 수 있다.(함수 오버로드)