# Chapter03 유니언과 리터럴

타입스크립트가 해당 값을 바탕으로 추론을 수행하는 두 가지 핵심 개념

- union : 값에 허용된 타입을 두 개 이상의 가능한 타입으로 확장하는 것
- narrowing : 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 좁히는 것

### 3.1 유니언 타입

이거 혹은 저거

```jsx
let mathematician: string | undefined =
  Math.ramdom() > 0.5 ? undeifined : 'Mark Goldburg'
```

- `number | string`의 타입을 준 경우 `toUpperCast()`와 `toFixed()`는 사용할 수 없다.

### 3.2 내로잉

- 타입을 좁히는 데 사용할 수 있는 논리적 검사를 타입 가드라고 한다.
- 타입 가드 방법
  - 값 할당을 통한 내로잉
  - 조건 검사를 통한 내로잉
  - typeof 검사를 통한 내로잉

**3.2.1 값 할당을 통한 내로잉**

변수에 값을 직접 할당하면 타입스크립트는 변수의 타입을 할당된 값의 타입으로 좁힌다. `number | string`으로 선언을 했어도 ‘Grace Hopper’ 값이 할당된 이후에는 string 타입이라는 것을 알게 된다.

- 변수가 나중에 유니언 타입으로 선언된 타입 중 하나의 값을 받을 수 있다.

### 3.3 리터럴 타입

원시 타입 중 어떤 것이 아닌 특정 원싯값으로 알려진 타입이 리터럴 타입이다.

```jsx
const mathematician: 'Mark Goldberg' = 'Mark Goldburg'
```

- boolean : true | false
- null과 undefined : 자기 자신, 즉 오직 하나의 리터럴 값만 가짐
- number : 0 | 1 | 2 … | 0.1 | 0.2 | …
- string : “” | ‘a’ | ‘c’ | … | ‘ab’ | …
- `let lifrespan: number | "ongoing" | "uncertain"`

### 3.4 엄격한 null 검사

### 3.5 타입 별칭

```tsx
type RawData = boolean | number | string | null | undefined

let rawDataFirst: RawData
let rawDataSecond: RawData
```

**3.5.1 타입 별칭은 자바스크립트가 아닙니다.**

- 타입 별칭은 자바스크립트로 컴파일되지 않는다. “개발 시”에만 존재한다.

```tsx
type SomeType = string | undefined

console.log(SomeType)
// Error: 'SomeType' only refers to a type, but is being used as a value here.
```

**3.5.2 타입 별칭 결합**

```tsx
type Id = number | string
type IdMaybe = Id | undefined | null

// 위 두 개의 순서가 바뀌어도 상관 없다.
```
