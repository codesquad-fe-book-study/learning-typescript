# Chapter01 자바스크립트에서 타입스크립트로

### 자바스크립트의 함정

```jsx
typeof 43 //'number'
typeof 3.14 //'number'
typeof NaN //'number'
```

```jsx
4 + '7' //'47'
4 * '7' // 28
2 + true // 3
false - 3 // -3
```

```jsx
Number('590') // 590
Number('aaa!') // NaN

Boolean(1) // true
Boolean(0) // false

String(true) // 'true'
String(false) // 'false'

String('4483') //'4483'
```

[\***\*Typing: Static vs Dynamic, Weak vs. Strong\*\*** ](https://www.notion.so/Typing-Static-vs-Dynamic-Weak-vs-Strong-872ddd5d06504a82b6e3aa49780517c1)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5a690d0c-31ea-442b-98fe-254d290c3aa2/Untitled.png)

```jsx
const length = 12
const num = length(54)
```

The next kind of error is when you confuse one thing for another.

다음 에러는 한 가지를 다른 것과 혼동하는 것이다.

fist, we create a constant. Remember, it’s like giving a name to something, in this case - giving a name `length` to a number 12. Then on the second line, we call a function `length` and pass an argument - number 54. But wait! `length` is not a function! It’s a number. Numbers are not functions, not boxes that do stuff.

먼저 상수를 만든다. 이 것은 어떤 것에 이름을 붙이는 것과 같다. 이 경우는 숫자 12에 `length`라는 이름을 붙인 것이다. 두 번째 라인에서는 `length`함수를 호출하고 숫자 54를 인수로 전달한다. 하지만 `length`는 함수가 아니다. 숫자이다. 숫자는 함수가 아니며 무언가를 하는 상자가 아니다.

```bash
TypeError: length is not a function
```

And this is exactly how JavaScript will complain: This is a **Type Error** - the type of the thing you’ve used is wrong. JavaScript interpreter wouldn’t tell you what the thing **is**, but it will tell you what it **isn’t**. `length`is not a function. Type Error is like asking your cat to do the laundry. You probably wanted to ask your roommate.

**Type Error**, 이것이 바로 자바스크립트의 complain인데 사용한 타입이 잘못되었다는 error이다. 자바스크립트 인터프리터는 무엇이 잘못되었는지 알려주지 않을 것이지만 그 것이 아니라는 것은 알려줄 것이다. `length`는 함수가 아니다. type error는 고양이에게 빨래를 부탁하는 것과 같다. 룸메이트에게 물어보고 싶었겠지.

In programming “type” is a classification of information. This is a general term, and different programming languages deal with types in different ways. As you know by now, JavaScript somehow can see the difference between types. Function is one type, Number is another type, and you can’t just use a number as a function.

프로그래밍에서 “type”은 정보의 분류이다. 타입은 일반적인 용어이고 다른 프로그래밍 언어들은 다른 방식으로 타입을 다룬다. 자바스크립트는 어떻게든 타입 간의 차이를 알 수 있다. function은 타입 중 하나이고 number는 다른 타입이며 숫자를 함수로 사용할 수 없다.

```jsx
typeof 43 //'number'
typeof 3.14 //'number'
typeof NaN //'number'

typeof 'Berry' //'number'
typeof true //'number'
typeof false //'number'
```

`typeof` is a special operator that returns a string indicating the type. 42 and 3.14 are obviously numbers, some combination of letters in quotation marks is a string, and true and false are boolean. These are some of types in JavaScript - number, string, boolean. NaN means “not a number”, but the type of NaN is “number”. Another JavaScript weirdness. Those are the rules of this language.

`typeof`는 타입을 문자열로 반환하는 특수 연산자이다. 42와 3.14는 분명히 숫자이며, 따옴표와 문자의 조합은 문자열이며, true와 false는 boolean이다. 자바스크립트에는 number, string, boolean 등 몇 가지 타입이 있다. NaN은 ‘숫자가 아니다.’를 의미하지만 NaN의 타입은 number이다. 자바스크립트의 또 다른 괴상함이지만 이 것이 이 언어의 규칙이다.

Types are helpful. When we’ve tried running a number as if it was a function, JavaScript started complaining and we could see the problem and fix it. If there wasn’t any notion of types in JavaScript, we would either see some bizarre unexpected behavior or some mystic error. Instead of clear “length is not a function” we’d have something like “I’m sorry Dave, I’m afraid I can’t do that.”

타입은 유용하다. 우리가 숫자를 함수인 것처럼 실행하려고 했을 때 자바스크립트가 complain을 하기 시작했고 우리는 문제를 보고 고칠 수 있었다. 자바스크립의 타입에 대한 개념이 없다면 기괴하고 예기치 못한 상황이나 신비한 오류를 보게 될 것이다. 자바스크립트는 명확한 “length가 함수가 아니다.”라는 오류 대신에 “미안해, 난 그렇게 할 수 없을 것 같아.”와 같은 것을 사용할 것이다.

What if you create a variable, but give it any value? What type would that be? It’s not a number, not a string, not… anything. Because there is no value, right? JavaScript does something behind your back in this case. The variable without a value actually has a special value - ‘undefined’.

변수를 생성하지만 어떤 값이든 주게 되면 어떻게 될까? 어떤 타입이 좋을까? 값이 숫자도 아니고 문자도 아니라면.. 값이 없기 때문에 number도, string도, 아무 것도 아니다. 이런 경우 자바스크립트는 뒤에서 무언가를 한다. 값이 없는 변수에는 undefined라는 특별한 값이 있다.

```jsx
let a
console.log(a) // undefined
typeof a // 'undefined'
```

And the type of this variable is called ‘undefined’. So for example, type `number` has lots of potential values: 1, 2, -10, 69000, and other numbers. But type `undefined` has only on value - `undefined`.

그리고 이 변수의 타입을 undefined라고 한다. 예를 들어 1, 2, -10, 69000와 같은 많은 숫자들은 number type이다. 하지만 undefined type은 오직 undefined만 가질 수 있다.

There are two important things to understand when it comes to types in programming: dynamics vs static and weak vs strong. In order to understanding the difference between dynamic and static typing, we first have to look at how written programs become actual running programs. The code you write is usually converted into some other form that a computer knows how to run. This process is called compilation, and the peried of time this happens is called “compile time”. After compilation is over, the program is launched, and the period it’s running is called “runtime”.

프로그래밍 유형에는 두 가지 중요한 것이 있다. dynamics vs static와 weak vs strong. dynamic typing과 static typing을 이해하기 위해서는 먼저 작성된 프로그램이 어떻게 실제로 실행되는 프로그램이 되는지 살펴봐야 한다. 작성된 코드는 일반적으로 컴퓨터가 실행하는 방법을 아는 다른 형식으로 변환된다. 이 과정을 **컴파일**이라고 하고 이 과정이 일어나는 기간을 **컴파일 시간**이라고 한다. 컴파일 완료 후 프로그램이 실행되며 실행 중인 기간을 **런타임**이라고 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b219fce6-9df6-40d8-812f-4f06189a62d7/Untitled.png)

Some languages check the types and look for type errors during compile time. Those have static typing. Other languages check the types and look for type errors during runtime.

Another way to think about it: static typing means checking the types before running the program, dynamic typing means checking the types while running the program.

일부 언어는 컴파일 시간 동안 타입을 확인하고 type error를 찾는다. 이 언어들은 static typing을 한다. 다른 언어들은 런타임 동안 타입을 확인하고 오류를 찾는다.

static typing은 프로그램을 실행하기 전에 유형을 확인하는 것을 의미하고 dynamic typing은 프로그램을 실행하는 동안 유형을 확인하는 것을 의미한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6cc7a75c-0c09-4c71-91d5-5631f226c01b/Untitled.png)

C#, C++, Java, Go are statically typed languaes. If you create a number and try to treat it as a function in one of those language, you’ll get an error during compilation, and your program will not even try to run - it won’t get to that point because a type error would’ve been found before runtime, at compile time.

C#, C++, Java, Go는 정적으로 입력된 언어이다. 만약 해당 언어 중 하나로 숫자를 만들고 함수로 처리하려고 하면 컴파일 중에 오류가 발생하고 프로그램은 실행하려고도 하지 않는다. 런타임 전, 컴파일 시간에 type error가 발견됐기 때문이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27665561-381c-4946-982b-d5063da9207a/Untitled.png)

JavaScript, Ruby, PHP are dynamically typed languages. As you’ve seen before, if use the incorrect type, your program does run, and the error occurs only when that particular line of code is executed. Actually, JavaScript _usually_ doesn’t have any compilation at all, but that’s a topic for another lesson.

자바스크립트, 루비, PHP는 동적으로 입력되는 언어이다. 앞에서 보았듯이 잘못된 타입으로 사용을 하면 프로그램이 실행되고 특정 코드 라인이 실행될 때만 오류가 발생한다. 사실 자바스크립트는 보통 컴파일 기능이 전혀 없다.

Dynamic typing is not worse or better than static typing. Both ways have advantages and disadvantages. Dynamically typed languages are usually easier to learn and to write programs in, but, as you can imagine, it leads to more mistakes and bugs.

동적 입력이 정적 입력보다 나쁘거나 낫지 않다. 두 방법 모두 장점과 단점이 있다. 동적으로 입력되는 언어는 일반적으로 프로그램을 작성하기가 더 쉽지만 그 것은 더 많은 오류와 버그로 이어진다.

Now let’s talk about weak and string typing.

```jsx
4 + '7' //'47'
4 * '7' // 28
2 + true // 3
false - 3 // -3
```

Check out this JavaScript code. Adding number 4 to a string ‘7’ gives us a string ‘47’. JavaScript converted number 4 into a string ‘4’ and concatenated two strings - glued them together. JavaScript just took the liberty of assuming this is what we wanted. It’s hard to blame it - what did we wnat? Adding a number to a string - that doesn’t make sense. Some other language, like Ruby or Python would’ve just complained and not do anything. Multiplying number 4 by a string ‘7’ is, weell, 28, according to JavaScript. In this case, it converted string ‘7’ into number 7 and did the normal multiplication.

위 자바스크립트 코드를 보면 문자열 ‘7’에 숫자 4를 더하면 문자열 ‘47’이 나온다. 자바스크립트는 숫자 4를 문자열 ‘4’로 변환하고 두 문자열을 연결했다. 자바스크립트는 우리가 원하는 것이 이 것이라고 추측했다. 문자열에 숫자를 더하는 것은 말이 되지 않는다. 루비나 파이썬 같은 다른 언어라면 불평만 하고 아무 것도 하지 않았을 것이다. 위의 자바스크립트 코드에 따르면 숫자 4에 문자열 ‘7’을 곱하면 28이다. 이 경우 문자열 ‘7’을 숫자 7로 변환하여 곱셈을 수행했다.

JavaScript does this a lot. It knows about the types of different values but when types don’t match, it tries to assume and convert from type to type without telling you. Sometimes it’s useful, sometimes it’s mindboggling. This happens because JavaScript is a weakly typed language. It has the notion of types, but it’s like, “It’s only a game, why you have to be mad?”

자바스크립트는 이런 경우가 많다. 서로 다른 값의 타입을 알고 있지만 타입이 일치하지 않으면 사용자에게 알리지 않고 타입에서 타입으로 가정하고 변환하려고 한다. 때로는 유용하기도 하지만 때로는 걱정스럽기도 하다. 이것은 자바스크립트가 weakly typed laguage이기 때문이다. 자바스크립트는 타입에 대한 개념을 가지고 있지만, “단지 게임일 뿐인데, 왜 화를 내는 거야?”라고 말하는 것과 같다.

This is nothing to do with dynamic versus static typing, which is about WHEN to check for types. Strong versus weak is about HOW SERIOUS DO YOU GET while checking the types. You can say that weak typing is relaxed typing, and strong typing is static typing.

타입을 언제 확인하느냐는 동적, 정적 입력과는 아무런 관련이 없다. strong vs weak는 타입을 확인하는 동안 얼마나 심각해지는가이다. weak typing은 느긋하고 strong typing은 static typing이라고 할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a7af508f-9657-4821-a038-078e8ed51c0f/Untitled.png)

Unlike dynamic vs static, the strength of the typing system is a spectrum. JavaScript has very weak typing. PHP has somewhat strong typing. Python - even stronger. And all three are dynamically typed languages. So JavaScript does a lot of implicit conversions, but it also gives us tools to do explicit conversion ourselves.

dynamic vs static과 달리 typing system의 강도는 spectrum이다. 자바스크립트는 typing이 매우 약하다. PHP는 다소 강하다. 파이썬은 훨씬 더 강하다. 그리고 이 세가지 모두 dynamic typing 언어이다. 그래서 자바스크립트는 암묵적인 변환을 하지만 우리가 직접 명시적으로 변환할 수 있는 도구도 제공한다.

```jsx
Number('590') // 590
Number('aaa!') // NaN

Boolean(1) // true
Boolean(0) // false

String(true) // 'true'
String(false) // 'false'

String('4483') //'4483'
```

We can convert string to numbers and numbers to string, boolean to string etc like this. You can probably guess that implicit type conversion is not the best idea ever. Implicit means hidden, and hidden means it’s hard to understand and easy to make mistakes. The behavior of the program becomes less obvious. You write less code, yes, but the code is more fragile and less understandable.

이렇게 문자열을 숫자로, 숫자를 문자열로, boolean을 문자열로 변환할 수 있다. 아마도 암시적 타입 변환이 가장 좋은 생각이 아니라고 추측할 수 있을 것이다. 암묵적인 것은 숨겨진 것을 의미하고, 숨겨진 것은 이해하기 어렵고 실수하기 쉽다는 것을의미하고 프로그램의 행동은 덜 명확해진다. 코드를 적게 쓰지만 코드가 더 취약하고 이해하기 어렵다.
