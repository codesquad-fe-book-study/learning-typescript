# 4/8 #3 챕터 5~6

# Ch .5 함수

## 함수 매개변수

타입 정보가 선언되지 않으면 타입을 알 수 없음. **any타입으로 간주**되므로 절대 타입 지켜

변수와 똑같이 타입 애너테이션으로 선언가능하다.

```tsx
function sing(song: string) {
  console.log(`Singing: ${song}`);
}
```

### 필수 매개변수

매개변수를 명시하는 자체가 특정 개수로 인수를 받을 함수를 **선언**하는 것이라 타입과 상관없이 함수에 명시한 매개변수의 개수를 넘을 수 없다. 적게 받는 경우는 undefined로 할당되어 실행에 문제는 없다.

### 선택적 매개변수

```tsx
function foo(a: string, b?: string) {
  return c;
}
//첫번째 코드는 인수로 b를 **받거나 받지않거나** 두 경우 모두 가능
function foo(a: string, b: string | undefined) {
  return c;
}
//두번째 코드는 b에 전달할 인수가 없더라도 undefined로 **값을 명시**해줘야한다.
function foo(b?: string, a: string) {
  return c;
}
//세번째 코드처럼 선택적 매개변수가 맨 뒤에있지 않으면 **구문 오류 발생**
```

### 기본 매개변수

JS에서 선택적 매개변수를 선언할 떄 =와 값이 포함된 기본값을 제공할 수 있어서 타입스크립트 타입에 **암묵적으로** 함수내부에 | undefined 유니언 타입이 추가된다. 함수 매개변수도 변수와 같이 기본값X 애너테이션X인 경우 기본값을 기반으로 타입 유추한다.

### 나머지 매개변수

…스프레드 연산자로 선언한 매개변수도 **마지막에 위치**해야한다.

### 반환 타입

여러 개의 타입이 있는 값을 반환하는 경우 가능한 모든 반환 타입의 조합으로 유추한다.

**타입을 명시한 경우**

- 항상 동일한 타입의 값을 반환하도록 **강제**한다.
- 재귀 함수의 반환 타입을 통해 타입 유추하는 것을 금지한다.
- TS파일이 수백 개 이상처럼 많을 시에 타입 검사 속도를 높일 수 있다.

**_5.3 함수 타입 107 예시 이해가 잘 안된다_** 🤯

### void 반환 타입

즉시 실행 함수처럼 익명 함수이면서 반환 값이 없이 동작만 하는 함수를 TS에서 사용할 때 void를 사용가능하다.

또 두번째 코드처럼 반환값이 없는 경우 자동으로 반환 타입을 ‘void’로 추론하게된다. 지정하지 않아도 되지만, 다른 개발자가 함수를 사용할 때 반환값이 없는 함수인지 쉽게 파악할 수 있게 ‘void’ 타입으로 명시하는게 좋다고 지피티가 그랬습니다.

```tsx
function(): void {
  //불라불라
}();

function logMessage(message: string) {
  console.log(message);
}

//두번째처럼 반환값이 없는 경우
```

\*void는 함수의 반환 타입이 **무시**되는 것 값이 없는 경우 **undefined로 반환하는 경우**와 다르다.

### never 함수

절대 반환하지 않을 값을 명시하는 것 번역 열받음.이부분도 이해 개안됨. string이 아닐 경우에만 fail 동작인데 매개변수 타입이 스트링임 무엇?

# Ch.6 배열

JS 배열은 내부에 모든 타입의 값 혼합해서 저장가능하다.

### 주의 사항: 불안정한 멤버

JS에서조차도 배열의 길이보다 큰 인덱스로 접근하면 undefined를 반환한다. 타입스크립트 기본 컴파일러 설정에서도 오류가 나지않음.

<img width="866" alt="스크린샷 2023-04-09 오전 3 08 53" src="https://user-images.githubusercontent.com/114852081/230751626-f82ba982-fadb-4a65-bc5e-82b2aaad99bd.png">

## 튜플

각 인덱스의 타입을 구체적으로 고정해서 명시한다. 여러값을 할당할 때는 **튜플**과 **배열 구조 분해 할당**을 세트로 자주 쓴다.

### 튜플 추론

배열 리터럴을 보고 각 원소의 타입을 추론한다. 아주 똑똑이. 튜플의 요소는 **명시적으로 타입을 지정**할 수 있고, 명시했을 경우 지정한 타입으로 추론한다. **추론된 타입**은 배열의 **각 요소를 참조**할 때 사용된다.

### const 어서션

타입스크립트에서 타입을 유추할 때 **읽기 전용 값**으로 사용하도록 지시한다.

```tsx
const unionArray = [1157, "tomoe"] as const;
//배열 리터럴 뒤에 as const를 추가해서 사용
```

_as const를 사용해서 읽기 전용 배열을 반환하고, 이를 사용하는 코드는 튜플에서 값을 찾는 것에만 관심을 둔다? 이게 무슨뜻임 이전 예제처럼 값에 접근해서 값을 바꿀 수 없다? 값을 사용하지 못하면 읽기 전용을 어디다 쓰는지 의문_

<a href="https://ibb.co/QHnzzQH"><img src="https://i.ibb.co/qg9XXjg/2023-04-09-9-17-38.png" alt="2023-04-09-9-17-38" border="0"></a>

객체의 프로퍼티 중 값이 변경되면 안 되는 경우 해당 값을 ‘readonly’로 정의할 수 있다고한다.
